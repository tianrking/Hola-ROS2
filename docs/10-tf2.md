# 10 TF2 坐标变换 (TF2 Transform)

## 10.1 TF2 概述

### 10.1.1 什么是 TF2

**TF2 (Transform 2)** 是 ROS 2 中用于管理坐标变换的库。它跟踪多个坐标系之间的关系，允许开发者在不同坐标系之间转换数据（如点、向量、姿态）。

```
TF2 坐标系树示例：

                map (世界坐标系)
                 |
                 |  (2D 平面变换)
                 |
              odom (里程计坐标系)
                 |
                 |  (Z轴平移)
                 |
            base_link (机器人基座)
                 |
        ┌────────┼────────┐
        |        |        |
    camera  laser  base_footprint
    (相机)  (激光)   (底盘)
```

### 10.1.2 TF2 的用途

| 应用 | 说明 |
|-----|------|
| **传感器融合** | 将不同传感器的数据转换到统一坐标系 |
| **导航** | 将地图坐标系的目标转换为机器人坐标系 |
| **机械臂** | 计算末端执行器相对于基座的姿态 |
| **可视化** | 在 RViz2 中正确显示机器人状态 |

### 10.1.3 坐标系命名规范

| 命名 | 用途 |
|-----|------|
| `map` | 全局/世界坐标系，固定不变 |
| `odom` | 里程计坐标系，用于定位 |
| `base_link` | 机器人基座坐标系 |
| `base_footprint` | 机器人底盘投影到地面 |
| `camera_link` | 相机坐标系 |
| `laser_link` | 激光雷达坐标系 |

## 10.2 静态变换

### 10.2.1 静态变换节点

静态变换是不随时间变化的坐标系关系（如传感器相对于机器人基座的安装位置）：

```cpp
#include <rclcpp/rclcpp.hpp>
#include <tf2_ros/transform_broadcaster.h>
#include <geometry_msgs/msg/transform_stamped.hpp>
#include <tf2/LinearMath/Quaternion.h>

class StaticFrameBroadcaster : public rclcpp::Node {
public:
    StaticFrameBroadcaster() : Node("static_tf2_broadcaster") {
        // 创建 TF2 广播器
        tf_broadcaster_ = std::make_shared<tf2_ros::TransformBroadcaster>(this);

        // 发布静态变换
        publish_static_transform();
    }

private:
    std::shared_ptr<tf2_ros::TransformBroadcaster> tf_broadcaster_;

    void publish_static_transform() {
        geometry_msgs::msg::TransformStamped transform;

        // 设置时间戳和坐标系关系
        transform.header.stamp = this->get_clock()->now();
        transform.header.frame_id = "base_link";        // 父坐标系
        transform.child_frame_id = "camera_link";       // 子坐标系

        // 设置平移 (传感器安装位置: 前方0.1m, 上方0.2m, 左方0.0m)
        transform.transform.translation.x = 0.1;
        transform.transform.translation.y = 0.0;
        transform.transform.translation.z = 0.2;

        // 设置旋转 (四元数: 无旋转)
        tf2::Quaternion q;
        q.setRPY(0, 0, 0);  // Roll, Pitch, Yaw
        transform.transform.rotation.x = q.x();
        transform.transform.rotation.y = q.y();
        transform.transform.rotation.z = q.z();
        transform.transform.rotation.w = q.w();

        // 发送变换
        tf_broadcaster_->sendTransform(transform);

        RCLCPP_INFO(this->get_logger(), "Published static transform: %s -> %s",
                    transform.header.frame_id.c_str(),
                    transform.child_frame_id.c_str());
    }
};
```

### 10.2.2 使用静态变换发布器

ROS 2 提供了专门的静态变换发布器节点：

```bash
ros2 run tf2_ros static_transform_publisher \
    x y z yaw pitch roll frame_id child_frame_id
```

**示例：**

```bash
# 发布相机相对于基座的静态变换
ros2 run tf2_ros static_transform_publisher \
    0.1 0.0 0.2 0 0 0 base_link camera_link

# 使用 Launch 文件发布多个静态变换
```

## 10.3 动态变换

### 10.3.1 动态变换广播器

动态变换随时间变化（如机器人移动、关节运动）：

```cpp
#include <rclcpp/rclcpp.hpp>
#include <tf2_ros/transform_broadcaster.h>
#include <geometry_msgs/msg/transform_stamped.hpp>
#include <tf2/LinearMath/Quaternion.h>
#include <cmath>

class DynamicFrameBroadcaster : public rclcpp::Node {
public:
    DynamicFrameBroadcaster() : Node("dynamic_tf2_broadcaster") {
        tf_broadcaster_ = std::make_shared<tf2_ros::TransformBroadcaster>(this);

        // 定时器定期发布变换
        timer_ = this->create_wall_timer(
            std::chrono::milliseconds(50),
            std::bind(&DynamicFrameBroadcaster::broadcast_timer_callback, this)
        );
    }

private:
    std::shared_ptr<tf2_ros::TransformBroadcaster> tf_broadcaster_;
    rclcpp::TimerBase::SharedPtr timer_;
    float angle_ = 0.0;

    void broadcast_timer_callback() {
        geometry_msgs::msg::TransformStamped transform;

        transform.header.stamp = this->get_clock()->now();
        transform.header.frame_id = "odom";
        transform.child_frame_id = "base_link";

        // 更新位置（模拟机器人移动）
        transform.transform.translation.x = std::cos(angle_) * 2.0;
        transform.transform.translation.y = std::sin(angle_) * 2.0;
        transform.transform.translation.z = 0.0;

        // 更新旋转（朝向移动方向）
        tf2::Quaternion q;
        q.setRPY(0, 0, angle_);
        transform.transform.rotation.x = q.x();
        transform.transform.rotation.y = q.y();
        transform.transform.rotation.z = q.z();
        transform.transform.rotation.w = q.w();

        tf_broadcaster_->sendTransform(transform);

        angle_ += 0.01;  // 增加角度
    }
};
```

### 10.3.2 广播多个变换

```cpp
void broadcast_multiple_transforms() {
    // 变换1: odom -> base_link
    geometry_msgs::msg::TransformStamped t1;
    t1.header.stamp = this->get_clock()->now();
    t1.header.frame_id = "odom";
    t1.child_frame_id = "base_link";
    // ... 设置 t1 的值 ...
    tf_broadcaster_->sendTransform(t1);

    // 变换2: base_link -> laser_link
    geometry_msgs::msg::TransformStamped t2;
    t2.header.stamp = this->get_clock()->now();
    t2.header.frame_id = "base_link";
    t2.child_frame_id = "laser_link";
    // ... 设置 t2 的值 ...
    tf_broadcaster_->sendTransform(t2);
}
```

## 10.4 监听变换

### 10.4.1 变换监听器

```cpp
#include <rclcpp/rclcpp.hpp>
#include <tf2_ros/transform_listener.h>
#include <tf2_ros/buffer.h>
#include <geometry_msgs/msg/point_stamped.hpp>
#include <tf2/exceptions.h>

class TransformListener : public rclcpp::Node {
public:
    TransformListener() : Node("tf2_listener") {
        // 创建 TF2 缓冲区和监听器
        tf_buffer_ = std::make_shared<tf2_ros::Buffer>(this->get_clock());
        tf_listener_ = std::make_shared<tf2_ros::TransformListener>(*tf_buffer_);

        // 定时器尝试查询变换
        timer_ = this->create_wall_timer(
            std::chrono::milliseconds(1000),
            std::bind(&TransformListener::on_timer, this)
        );
    }

private:
    std::shared_ptr<tf2_ros::Buffer> tf_buffer_;
    std::shared_ptr<tf2_ros::TransformListener> tf_listener_;
    rclcpp::TimerBase::SharedPtr timer_;

    void on_timer() {
        geometry_msgs::msg::TransformStamped transform;

        try {
            // 查询变换
            transform = tf_buffer_->lookupTransform(
                "base_link",       // 目标坐标系
                "camera_link",     // 源坐标系
                tf2::TimePointZero // 使用最新可用变换
            );

            // 输出变换结果
            RCLCPP_INFO(this->get_logger(), "Translation: x=%.3f, y=%.3f, z=%.3f",
                        transform.transform.translation.x,
                        transform.transform.translation.y,
                        transform.transform.translation.z);

        } catch (tf2::TransformException & ex) {
            RCLCPP_WARN(this->get_logger(), "Could not transform: %s", ex.what());
            return;
        }

        // 变换点
        geometry_msgs::msg::PointStamped point_in;
        point_in.header.frame_id = "camera_link";
        point_in.point.x = 1.0;
        point_in.point.y = 0.0;
        point_in.point.z = 0.0;

        try {
            geometry_msgs::msg::PointStamped point_out;
            point_out = tf_buffer_->transform(point_in, "base_link");

            RCLCPP_INFO(this->get_logger(), "Point in base_link: x=%.3f, y=%.3f, z=%.3f",
                        point_out.point.x, point_out.point.y, point_out.point.z);

        } catch (tf2::TransformException & ex) {
            RCLCPP_WARN(this->get_logger(), "Could not transform point: %s", ex.what());
        }
    }
};
```

### 10.4.2 Python 变换监听器

```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from tf2_ros import TransformException
from tf2_ros.buffer import Buffer
from tf2_ros.transform_listener import TransformListener
from geometry_msgs.msg import PointStamped


class TransformListener(Node):

    def __init__(self):
        super().__init__('tf2_listener')

        # 创建 TF2 缓冲区和监听器
        self.tf_buffer = Buffer()
        self.tf_listener = TransformListener(self.tf_buffer, self)

        # 定时器
        self.timer = self.create_timer(1.0, self.on_timer)

    def on_timer(self):
        try:
            # 查询变换
            transform = self.tf_buffer.lookup_transform(
                'base_link',
                'camera_link',
                rclpy.time.Time())

            self.get_logger().info(
                f'Translation: x={transform.transform.translation.x:.3f}, '
                f'y={transform.transform.translation.y:.3f}, '
                f'z={transform.transform.translation.z:.3f}'
            )

        except TransformException as ex:
            self.get_logger().warn(f'Could not transform: {ex}')
            return

        # 变换点
        point_in = PointStamped()
        point_in.header.frame_id = 'camera_link'
        point_in.point.x = 1.0
        point_in.point.y = 0.0
        point_in.point.z = 0.0

        try:
            point_out = self.tf_buffer.transform(point_in, 'base_link')
            self.get_logger().info(
                f'Point in base_link: x={point_out.point.x:.3f}, '
                f'y={point_out.point.y:.3f}, z={point_out.point.z:.3f}'
            )
        except TransformException as ex:
            self.get_logger().warn(f'Could not transform point: {ex}')


def main():
    rclpy.init()
    node = TransformListener()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass

    node.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

## 10.5 TF2 命令行工具

### 10.5.1 查看坐标系树

```bash
# 查看所有坐标系
ros2 run tf2_tools view_frames

# 输出 frames.pdf 文件，可视化坐标系树
```

### 10.5.2 查看变换

```bash
# 查看两个坐标系之间的变换
ros2 run tf2_ros tf2_echo base_link camera_link

# 查看特定时间的变换
ros2 run tf2_ros tf2_echo base_link camera_link 0
```

### 10.5.3 静态变换发布器

```bash
# 发布静态变换
ros2 run tf2_ros static_transform_publisher \
    0.1 0.0 0.2 \
    0.0 0.0 0.0 \
    base_link camera_link

# 参数说明: x y z yaw pitch roll parent_frame child_frame
```

### 10.5.4 变换监控器

```bash
# 监控变换延迟
ros2 run tf2_ros tf2_monitor

# 监控特定变换
ros2 run tf2_ros tf2_monitor source_frame:=base_link target_frame:=camera_link
```

## 10.6 TF2 与 RViz2

### 10.6.1 在 RViz2 中显示 TF

1. 打开 RViz2：`ros2 run rviz2 rviz2`
2. 点击左下角 "Add" 按钮
3. 选择 "TF"
4. TF 将在 3D 视图中显示为坐标系轴

### 10.6.2 TF 显示设置

| 设置 | 说明 |
|-----|------|
| **Show Axes** | 显示坐标系轴 |
| **Show Names** | 显示坐标系名称 |
| **Marker Scale** | 坐标系轴的显示大小 |
| **Update Interval** | 更新频率 |

## 10.7 坐标系树设计

### 10.7.1 标准移动机器人坐标系树

```
map                     # 全局地图坐标系
  |
  └─ odom              # 里程计坐标系
      |
      └─ base_link     # 机器人基座
          |
          ├─ base_footprint  # 底盘投影
          ├─ laser_link       # 激光雷达
          ├─ camera_link      # 相机
          └─ imu_link         # IMU
```

### 10.7.2 机械臂坐标系树

```
base_link           # 基座
  |
  ├─ link1          # 关节1
  │   └─ link2      # 关节2
  │       └─ link3  # 关节3
  │           └─ end_effector  # 末端执行器
  │
  └─ camera         # 固定相机
```

## 10.8 最佳实践

### 10.8.1 坐标系设计原则

| 原则 | 说明 |
|-----|------|
| **清晰命名** | 使用描述性的坐标系名称 |
| **最小树** | 避免不必要的坐标系 |
| **静态 vs 动态** | 静态变换用 static_transform_publisher |
| **时间戳** | 使用正确的时间戳 |

### 10.8.2 常见错误

| 错误 | 解决方法 |
|-----|---------|
| **坐标系不存在** | 检查坐标系树: `ros2 run tf2_tools view_frames` |
| **变换过期** | 增加超时时间或检查发布频率 |
| **环路** | TF2 树不能有环路 |
| **时间戳问题** | 使用 `tf2::TimePointZero` 获取最新变换 |

## 10.9 下一步

学习 TF2 后，您可以：

1. **[11 Custom Interfaces](./11-custom-interfaces.md)** - 创建自定义消息类型
2. **[22 URDF](./22-urdf.md)** - 创建机器人模型

---
**✅ 10 TF2 坐标变换 - 已完成**
